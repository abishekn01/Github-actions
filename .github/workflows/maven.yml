name: CI/CD Pipeline - Maven (Java) with SonarQube + Docker + Remote Deploy

# Triggers
on:
  push:
    branches: [ "main", "release/*" ]
    tags: [ 'v*.*.*' ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      deploy:
        description: 'Deploy after build?'
        required: false
        default: 'true'

# Prevent duplicate runs for the same head ref
concurrency:
  group: ci-cd-${{ github.ref }}
  cancel-in-progress: true

env:
  # Non-secret env usable by jobs; override with job/env if needed
  APP_NAME: bankingapp
  IMAGE_NAME: ${{ secrets.DOCKERHUB_USERNAME }}/bankingapp
  SONAR_PROJECT_KEY: bankingapp

jobs:
  ################################################################
  # 1) Build & Test (matrix)
  # runs in parallel for each java version in the matrix
  ################################################################
  build:
    name: Build & Test (Java ${{ matrix.java-version }})
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        java-version: [17, 21]
    timeout-minutes: 30
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK ${{ matrix.java-version }}
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: ${{ matrix.java-version }}
          cache: maven

      - name: Cache SonarScanner (optional)
        uses: actions/cache@v4
        with:
          path: ~/.sonar
          key: sonar-${{ runner.os }}-v1

      - name: Cache Maven local repo
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: maven-${{ matrix.java-version }}-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            maven-${{ matrix.java-version }}-

      - name: Build with Maven
        id: mvn_build
        run: |
          set -euo pipefail
          mvn -B -DskipTests=false clean verify
        # capture logs on failure
        continue-on-error: false

      - name: Upload build artifact (jar)
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: app-jar-${{ matrix.java-version }}
          path: target/*.jar

  ################################################################
  # 2) SonarQube analysis (depends on build success)
  ################################################################
  sonar:
    name: SonarQube Analysis
    runs-on: ubuntu-latest
    needs: build
    timeout-minutes: 20
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 17 (SonarScanner)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 17

      - name: Cache Maven for sonar
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: sonar-mvn-${{ hashFiles('**/pom.xml') }}

      - name: Run SonarQube Scanner
        env:
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          set -euo pipefail
          if [ -z "${SONAR_HOST_URL:-}" ] || [ -z "${SONAR_TOKEN:-}" ]; then
            echo "SONAR_HOST_URL or SONAR_TOKEN not set - skipping Sonar analysis"
            exit 1
          fi
          mvn -B sonar:sonar \
            -Dsonar.projectKey=${{ env.SONAR_PROJECT_KEY }} \
            -Dsonar.host.url=${SONAR_HOST_URL} \
            -Dsonar.login=${SONAR_TOKEN}
      # if sonar fails we want to stop pipeline (treat as gating)
      continue-on-error: false

  ################################################################
  # 3) Docker Build & Push
  # Depends on build job (so compiled artifacts exist)
  ################################################################
  docker_build:
    name: Docker Build & Push
    runs-on: ubuntu-latest
    needs: [build, sonar]
    timeout-minutes: 30
    environment: production
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up QEMU (for multi-arch if used)
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to DockerHub
        uses: docker/login-action@v3
        with:
          registry: docker.io
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Build and push image
        id: build_and_push
        run: |
          set -euo pipefail
          IMAGE=${{ env.IMAGE_NAME }}:${{ github.sha }}
          echo "Building image $IMAGE"
          docker build -t "$IMAGE" .
          docker push "$IMAGE"
          echo "::set-output name=image::$IMAGE"
        # fail the job if build or push fails
      - name: Save image tag to outputs
        run: echo "IMAGE_TAG=${{ steps.build_and_push.outputs.image }}" >> $GITHUB_ENV

  ################################################################
  # 4) Deploy - SSH to remote host and pull the image & run (depends on docker_build)
  ################################################################
  deploy:
    name: Deploy to Remote Server
    runs-on: ubuntu-latest
    needs: docker_build
    if: needs.docker_build.result == 'success' && (github.event.inputs.deploy != 'false' || github.ref_type == 'tag')
    timeout-minutes: 20
    steps:
      - name: Ensure SSH key is available
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      - name: Add known hosts (optional)
        run: |
          if [ -n "${{ secrets.DEPLOY_HOST }}" ]; then
            ssh-keyscan -H "${{ secrets.DEPLOY_HOST }}" >> ~/.ssh/known_hosts || true
          fi

      - name: Remote pull & run docker container (via SSH)
        env:
          IMAGE: ${{ env.IMAGE_NAME }}:${{ github.sha }}
        run: |
          set -euo pipefail
          USER=${{ secrets.DEPLOY_USER }}
          HOST=${{ secrets.DEPLOY_HOST }}
          # Example commands executed on remote host - adjust as needed
          ssh -o StrictHostKeyChecking=no ${USER}@${HOST} << 'EOF'
            docker login -u "${DOCKERHUB_USERNAME}" -p "${DOCKERHUB_PASSWORD}" || true
            docker pull "${IMAGE}" || exit 1
            docker stop ${APP_NAME} || true
            docker rm ${APP_NAME} || true
            docker run -d --restart=always --name ${APP_NAME} -p 8080:8080 "${IMAGE}" || exit 1
            # optional: cleanup old images
            docker image prune -f || true
          EOF
        # NOTE: docker login in remote uses env - we pass them below via SSH env interpolation
        # For security, pass secrets via ssh-agent or use ephemeral tokens in a production setup.

  ################################################################
  # 5) Notifications (always runs)
  ################################################################
  notify:
    name: Notify Slack & GitHub on Completion
    runs-on: ubuntu-latest
    needs: [build, sonar, docker_build, deploy]
    if: always()
    steps:
      - name: Determine overall status
        id: status
        run: |
          echo "jobs_status=SUCCESS" > status.txt
          if [[ "${{ needs.build.result }}" != "success" ]]; then echo "jobs_status=BUILD_FAILED" > status.txt; fi
          if [[ "${{ needs.sonar.result }}" != "success" ]]; then echo "jobs_status=SONAR_FAILED" > status.txt; fi
          if [[ "${{ needs.docker_build.result }}" != "success" ]]; then echo "jobs_status=DOCKER_FAILED" > status.txt; fi
          if [[ "x${{ needs.deploy.result }}" != "x" && "${{ needs.deploy.result }}" != "success" ]]; then echo "jobs_status=DEPLOY_FAILED" > status.txt; fi
          cat status.txt
          echo "::set-output name=jobs_status::$(cat status.txt)"
      - name: Slack notification
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ steps.status.outputs.jobs_status }}
          fields: repo,commit,author
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
      - name: Create GitHub issue when pipeline failed
        if: ${{ steps.status.outputs.jobs_status != 'jobs_status=SUCCESS' }}
        uses: peter-evans/create-issue-from-file@v4
        with:
          title: "CI/CD pipeline failure: ${{ github.ref }} (${{ github.sha }})"
          content-file: ./ci_failure.md
          labels: ci-failure
        # The file ci_failure.md must be created earlier or add inline content; for brevity assume repo contains template.
